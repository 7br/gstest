###############################################################################
###########      Generated by GRAPE Python SDK         ########################
###############################################################################

from libcpp.string cimport string
from libcpp.queue cimport priority_queue
from libcpp.pair cimport pair
from libcpp cimport bool
from libcpp.vector cimport vector

from graphscope cimport AdjListT
from graphscope cimport ComputeContext
from graphscope cimport Fragment
from graphscope cimport MessageStrategy
from graphscope cimport Operation
from graphscope cimport NodeT
from graphscope cimport NodeRangeT

ctypedef pair[double, NodeT] item

cdef public void Initialize(Fragment* frag, ComputeContext* context):
  cdef NodeRangeT vertices = frag.Vertices()
  context.init_value(vertices, 10000000.0)
  context.register_sync_buffer(Operation.OP_MIN, MessageStrategy.kSyncOnOuterVertex)

cdef public void IncEval(Fragment* frag, ComputeContext* context):
  cdef NodeRangeT inner_vertices = frag.InnerVertices()

  cdef priority_queue[pair[double, NodeT]] heap
  cdef vector[bool] modified = [ False for i in range(inner_vertices.size()) ]

  for v in inner_vertices:
    if (context.is_updated(v)):
      dist = context.get_vertex_value(v)
      heap.push(item(-dist, v))

  while True:
    u = heap.top().second
    distu = -(heap.top().first)
    heap.pop()
  
    if modified[u.GetValue()]: # GetId() is better
      continue
    modified[u.GetValue()] = True

    edges = frag.GetOutgoingAdjList(u)
    for e in edges:
      dst = e.neighbor
      distv = distu + e.data
      if context.get_vertex_value(dst) > distv:
        context.set_vertex_value(dst, distv)
        if frag.IsInnerVertex(dst):
          heap.push(item(-distv, dst))
